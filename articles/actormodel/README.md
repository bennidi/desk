While playing around with different design solutions for concurrency issues, I enevitably stumbled upon the actor model, which has become quite popular by now. Writing software for a multi-threaded (read: highly concurrent) environment requires to handle things like process synchronization, data dependencies, visibility while avoiding nasty side effects like deadlocks and the unlimited possibilities for race conditions.

Synchronization mechanisms like semaphores and other types of locks present a pretty low level solution that still leaves much of the thinking to the developer. He has to find all signifant variants of program execution and ensure that all threads are always correctly synchronized. This is especially difficult because bugs are not easily reproducible and which also makes it hard to write convincing tests. So there is a strong need for programming models that fit more naturally to the world of parallel program execution. One of those design approaches is the actor based programming.

The benefits of the actor model is that it tries to eliminate shared mutable state (which is one of the major evils in concurrent programming) by localizing computations and data mutations into single- threaded components, called actors. So each actor is accessed non-concurrently and works on its local copy of data, the system takes care of spawning actors and delegating work to them. Actors communicate via immutable messages and communication paths can be setup very flexibly and dynamically reordered. To me, the actor model is a design approach that relies on the very principles of object oriented design: Collaborating objects with well-defined responsibilities which encapsulate state and communicate using immutable messages. Lately, I stumbled upon [this talk](http://www.infoq.com/presentations/Akka-Actors?utm_source=infoq&utm_medium=videos_homepage&utm_campaign=videos_row1) on infoq.com and it helped me to see actors from a different perspective.

Now, I understand that by using actors you additionally start to think about your system in terms of its topology – a network of specialized nodes and the communication flow between them. Structurally, an actor corresponds to a node in this topology graph and different nodes are grouped to form coherent subsystems. From a behavioral view actors form hierarchies where some actors manage others  – which in turn may manage just another set of actors.

Each actor class  is a point for extension. It can be replaced, refined or incorporated into a newly created subsystem. Because actors communicate by passing immutable messages, communication can be intercepted and rerouted in a very flexible way. I do see several analogies to AOP principles, which is basically about refining existing code with modular extensions (by using pointcuts and advises). With actors pointcuts are message passing and an advice is just an actor that takes over the control before some other actor is invoked. Intercepting messages and introducing additional behaviour in form of new actors is the natural way to go.

Synchronization of actors is usually done by a queueing system which may become the overall bottleneck for systems with very high-transaction rates. This reportedly was one reason for the invention of the Disruptor framework since the synchronization of actors started to eat up  most of the processing time when many transactions where processed in parallel. 
