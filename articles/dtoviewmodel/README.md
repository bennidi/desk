Well, here I am having to take care of the communication between presentation and domain layer in a multi-tier and pretty much traditionally layered software system. The software was designed following many ideas of the Domain Driven Design approach, the backend code was in good shape and now it was time to connect it to the frontend. But how?

The first idea was to avoid exposure of the domain objects to the view such that they do not get tied together. Thus, there is the need to introduce a new kind of object that represents the parts of the domain model that need to make it to the view. Everybody agreed on using the so called data transfer object for this purpose. But then you also need to map between the two worlds and a lot of new code and questions arise. So mabye a DTO is not the right way to go?!

Generally a DTO is what its name suggests, a simple object without any behaviour that is used to transfer data across system boundaries [1](http://martinfowler.com/eaaCatalog/dataTransferObject.html). [This post](http://msdn.microsoft.com/en-us/magazine/ee236638.aspx) adds the separation of concern aspect and also points out the maintenance impact of having a lot of DTOs in your codebase. Then there is this so called view model, that some people (including me) confused with DTOs (see [this post](http://stackoverflow.com/questions/1982042/dto-viewmodel)) but that should have some kind of behaviour. I think the relation between the two is summed up very clearly in this post which also includes an implementation proposal that could be useful in some scenarios and definitely reduces the amount of code one needs to write.

Personally I don't have the experience to discuss the view model DTO relation but I do know that I dislike all objects that do not know how to behave. Being a value object is not a good reason for existence (a map would do), especially if I use it with general assembly patterns and some reflective framework technology that does not even need to know my concrete types.

This thing kept me thinking and I ended up having an idea. I don't know if it classifies as a view model but it is a model used by the view although it does not necessarily contain view specific information. The more importand thing about it is that is does not create much overhead to the application. I think there must already be posts about that approach since I feel it is an obvious one but my search did not bring up any, so in case I just repeat please have mercy. But before I explain the implementation approach I want to make a point why I think that you should not expose your domain objects directly to the view.

> "It's all about separation of concern – decoupling domain model and presentation layer"

It's as simple as that: Decoupling the domain layer from the view layer allows bigger changes to the application frontend to be done without modifications to service or domain layer. Changes can be applied to GUI components and the view model such that **view layer and domain model can evolve independently**.

Although both models are strongly related to each other ( the view model is mainly a custom representation (=view) of the domain model ) they do vary in different aspects. Since the design of the view layer aligns with the steps of user interactions required by the usecases, its model tends to have a **different granularity** than the domain model. Additionally data types in both models may be different and the view model might provide access to other functionality like syntactical validation, internationalization and even technology specific properties.

For me that's enough good reasons to have some kind of abstraction between view and domain. But I don't want the trade off traditional DTO implementation implies. I don't want to code potentially n data transfer objects AND their corresponding transformations for (maybe only) one domain object. And I don't want to put transformation logic into the service layer or pollute my repositories with toDTO(…) and fromDTO(…) methods. Also, I would like to avoid the use of a generic transformation framework that may require me to define mappings as xml or annotations and introduce just another model (the mapping model) and code artifacts into my code base.

> Designing the view model as a thin wrapper around the domain model

So, I asked myself, what if I treat the view model as a thin wrapper around the domain model objects and expose just the properties and functionality that I care about and that is valid for my specific use case? Then I could use the domain objects as delegates and have my IDE generate all the delegate methods I need. It would not be necessary to define any transformations since the objects managed by the view model can directly be used inside the services and domain layer. All additional transformation steps like data type mapping, string mutations, formatting etc. can be encapsulated in the view model class itself. In a lot of cases there wouldn't even be any transformation required.

This approach would allow me to initially define the view model analogous to the domain model and then have the view model evolve over time as it gets tailored to the specific usecase requirements. There would be no mapping overhead, no additional transformations and I could reuse some of the functionality of the domain model that is also valid in the context of the view layer, e.g. all the operations that modify the object graph like adding an address to a person, adding or removing an item to the shopping cart etc.
